---
title: promise
catalog: true
comments: true
date: 2021-02-20 14:38:22
subtitle: promise对象和原型的方法
header-img: promise.png
tags:
- javascript
categories:
- javascript
---

# Promise介绍

简单来说就是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)

```javascript
const p = new Promise((resolve,reject) => {})
```



# 原型继承

> 所有的promise实例都具有这个方法



## Promise.prototype.then()

```javascript
// fnc1 => resolve回调函数   func2 => reject回调函数 
p.then(func1,func2) 
p.then(func1) 
p.then(null,func2)  ==  catch()  
```



## Promise.prototype.catch()

1. 错误具有冒泡性质，所以catch可以捕获前面所有的错误 
2. catch也可以再抛出错误

```javascript
p.then(() => {}).catch((err) => {}) 
```



## Promise.prototype.finally()

ES2018

```javascript
p.then().catch().finally()
```



# Promise.all()

传入Promise实例数组，不是promise实例，也会被promise.resolve()转换为promis实例 最后包装成一个新的实例 

```javascript
const p = Promise.all([p1,p2,p3]) 
```



1. 数组实例状态全为fulfilled，才为fulfilled，将数组的本身传给resolve回调 的参数以数组的方式传给all实例 

2. 数组中一个为rejected，则为rejected,第一个rejected参数传进 

3. 作为参数的promise有catch，则rejected时不会触发all的catch，而是将自身catch 后的参数添加进数组传给all



# Promise.race()

跟随第一个状态改变 

```javascript
const p = Promise.race([p1,p2,p3]) 
```



实例： 请求超时报错

```javascript
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
```



# Promise.allSettled()

ES2020

```javascript
const p = Promise.allSettled([p1,p2,p3])

当传入的数组实例的状态改变完成后，状态变成fulfilled，不会变成rejected

传入的参数如下：
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]
```



# **Promise.any()**

ES2021

```javascript
const p = Promise.any([p1,p2,p3]])
```



1.至少一个为fulfilled，才为fulfilled
2.全为rejected，才为rejected
3.Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例



# **Promise.resolve()**

```javascript
将现有对象转换为promise对象
等同于：new Promise(resolve => resolve())

1.参数是promise实例，则直接输出

2.参数是一个thenable对象，转换为promise对象后立即执行then方法
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};

let p1 = Promise.resolve(thenable);
p1.then(function (value) {
  console.log(value);  // 42
});

3.参数不具有then()方法的对象，或则根本不是对象
返回一个新的promise对象，状态为resolved，回调函数会立即执行
const p = Promise.resolve('Hello');

p.then(function (s) {
  console.log(s)
});
// Hello

4.不带有任何参数
返回新的状态为resolved的promise对象
```



注意点：立即resolve()的promise对象，是在本轮“事件循环”的结束时执行，而不是在下一轮“事件循环”的开始时

```javascript
setTimeout(function () {
  console.log('three');
}, 0);

Promise.resolve().then(function () {
  console.log('two');
});

console.log('one');

// one
// two
// three
```



# **Promise.reject()**

返回状态为rejected的promise实例

```javascript
等同于new Promise(reject => reject())

Promise.reject()方法的参数，会作为reject的理由，变成后续方法的参数
Promise.reject('出错了')
.catch(e => {
  console.log(e === '出错了')
})
```





# **Promise.try()**

利用promise指定then下一步流程，同步函数同步执行，异步函数异步执行
(Promise里面的是可以同步函数同步执行，但是then和catch都是异步)

```javascript
1.async方法：
同步：
const f = () => console.log('now')
(async () => f())();
console,log('next');

异步：
(async () => f())().then().catch()

2.new Promise()
const f = () => console.log('now')
(() => new Promise(resolve => resolve(f())))()
console.log('next')

3.Promise.try()
const f = () => console.log('now');
Promise.try(f);
console.log('next');

Promise.try(() => database.users.get({id: userId}))
  .then(...)
  .catch(...)
```



> resolove（包括Promise.reolve()）回调都是在本轮事件循环末尾时执行